#!/usr/bin/perl

use warnings;
use strict;

use Getopt::Long;
use Pod::Usage;
use File::Path;
use File::Basename;
use File::Mirror;
use DateTime;
use Cwd;


# Configuration
my $git = "/usr/local/bin/git";         # path to git executable
my $base_path = "/var/www/git";         # home directory of 'git' user
my $deleted_path = "/var/www/git-deleted";    # deleted archive


my $user;

my %available_commands = (
    "help"              => \&help,
    "create"            => \&create,
    "delete"            => \&delete,
    "undelete"          => \&undelete,
    "rename"            => \&rename,
    "fork"              => \&fork,
    "list"              => \&list,
    "find"              => \&find,
    "git"               => \&git,
    "git-upload-pack"   => \&git_upload_pack,
    "git-receive-pack"  => \&git_receive_pack,
    "upload-pack"       => \&git_upload_pack,
    "receive-pack"      => \&git_receive_pack,
);

exit main();

sub main {
    chdir $base_path;

    GetOptions(
        'help' => sub { pod2usage(-verbose => 2); },
        'man' => sub { pod2usage(-verbose => 99,
            -sections => "NAME|SYNOPSIS|DESCRIPTION|AVAILABLE COMMANDS"); },
    ) or pod2usage(1);
    return pod2usage(1) if @ARGV != 1;

    $user = $ARGV[0];
    my $original_command = $ENV{'SSH_ORIGINAL_COMMAND'};

    if (not defined $original_command) {
        die "\$SSH_ORIGINAL_COMMAND must be set\n";
    }

    if ($original_command =~ /^\s*$/) {
        return &help();
    }

    my @command = split /\s+/, $original_command;
    my $cmd = shift @command;
    @ARGV = @command;

    my $routine = $available_commands{$cmd};
    return $routine->() if defined $routine;
    die "unknown command `$cmd'\n";
}

sub help {
    pod2usage(-verbose => 99, -sections => "AVAILABLE COMMANDS");
}

sub create {
    if (@ARGV != 1) {
        die "usage: create <repo>\n";
    }
    my $repo = repo_path_from_name($ARGV[0]);
    my $oldcwd = getcwd;
    mkpath($repo);
    chdir($repo) or die "failed to chdir: $!\n";
    run("git", "init", "--bare");
    chdir $oldcwd;
    return 0;
}

sub delete {
    my ($name) = @ARGV;
    if (@ARGV != 1) {
        die "usage: rename <repo>\n";
    }
    my $from = repo_path_from_name($name);
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    my $now = DateTime->now;
    my $to = "$deleted_path/$from." . $now->ymd('-') . '_' . $now->hms(':');
    mkpath(dirname($to));
    if (not rename($from, $to)) {
        die "rename('$from','$to') failed\n";
    }
    print "sucessfully deleted '$from'\n";
    return 0;
}

sub undelete {
    die "undelete not implemented\n";
}

sub rename {
    my ($from_name, $to_name) = @ARGV;
    if (@ARGV != 2) {
        die "usage: rename <from> <to>\n";
    }
    my $from = repo_path_from_name($from_name);
    my $to   = repo_path_from_name($to_name);
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    if ( -e $to ) {
        die "$to already exists\n";
    }
    if (not rename($from, $to)) {
        die "rename('$from','$to') failed\n";
    }
    print "sucessfully renamed '$from' to '$to'\n";
    return 0;
}

sub fork {
    my ($from_name, $to_name) = @ARGV;
    if (@ARGV != 2) {
        die "usage: fork <from> <to>\n";
    }
    my $from = repo_path_from_name($from_name, 1);
    my $to   = repo_path_from_name($to_name);
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    if ( -e $to ) {
        die "$to already exists\n";
    }
    mirror($from, $to);
    print "sucessfully forked '$from' to '$to'\n";
    return 0;
}

sub list {
    my $type = $ARGV[0] || "mine";
    if (@ARGV > 1 or ($type ne "all" and $type ne "mine")) {
        die "usage: list [all]\n";
    }
    my @repos;
    if ($type eq "all") {
        @repos = glob "*/*.git";
        print "No repositories found.\n" if @repos == 0;
    }
    else {
        @repos = glob "$user/*.git";
        print "You do not own any repositories.\n" if @repos == 0;
    }
    if (@repos > 0) {
        print join("\n", @repos) . "\n";
    }
    return 0;
}

sub find {
    my $regexp = $ARGV[0];
    if (@ARGV != 1) {
        die "usage: find <regexp>\n";
    }
    my @repos = grep /$regexp/, glob "*/*.git";
    if (@repos > 0) {
        print join("\n", @repos) . "\n";
    }
    else {
        print "No repositories found matching $regexp\n";
    }
    return 0;
}

sub git {
    my $cmd = shift(@ARGV);
    if (defined $cmd) {
        if ($cmd eq "upload-pack") {
            return &git_upload_pack();
        }
        if ($cmd eq "receive-pack") {
            return &git_receive_pack();
        }
    }
    die "usage: git (upload|receive)-pack <repo>\n";
}

sub git_upload_pack {
    if (@ARGV != 1) {
        die "usage: git upload-pack <repo>\n";
    }
    my $repo = repo_path_from_name($ARGV[0], 1);
    return run($git, "upload-pack", "--strict", $repo);
}

sub git_receive_pack {
    if (@ARGV != 1) {
        die "usage: git receive-pack <repo>\n";
    }
    my $repo = repo_path_from_name($ARGV[0]);
    return run($git, "receive-pack", $repo);
    # TODO call git update-server-info?
}


sub repo_path_from_name {
    my ($name, $read_allowed) = @_;
    if ($name =~ /^['"](.*)['"]$/) {
        $name = $1;
    }
    if ($name =~ m{^([a-z0-9_-]+)(\.git)?$}) {
        return "$user/$1.git";
    }
    elsif ($name =~ m{^/?([a-z0-9_-]+)/([a-z0-9_-]+)(\.git)?/?$}) {
        unless ($read_allowed or $1 eq $user) {
            die "you do not have permission to modify '$name'\n";
        }
        return "$1/$2.git";
    }
    else {
        die "invalid repository name '$name'; run `help' for more info\n";
    }
}


sub run {
    system(@_);
    if ($? == -1) {
        die "failed to execute: $!\n";
    }
    elsif ($? & 127) {
        die "child died with signal " . ($? & 127) . "\n";
    }
    return $? >> 8;
}


__END__

=head1 NAME

git-ssh-server - A more useful git-shell.

=head1 SYNOPSIS

git-ssh-server user

git-ssh-server (--help | --man)

=head1 DESCRIPTION

Run commands from $SSH_ORIGINAL_COMMAND as a git restricted shell, allowing
access only to the directories accessible by given user.

This script is usually run automatically by ssh, as in:

    ssh git@server create foo

with a properly set up .ssh/authorized_keys file will run:

    SSH_ORIGINAL_COMMAND='create foo' git-ssh-server jsmith

The user will only be allowed to modify git repositories under the path
allocated to jsmith.


=head1 AVAILABLE COMMANDS

In the following commands, <repo>, <from>, and <to> must be of the form
"[userdir/]reponame[.git]".  If "userdir" is not given, it is taken to be the
current user's directory.  The ".git" suffix is optional.  "reponame" can only
contain lowercase letters, numbers, underscores, and dashes.

=over

=item list [all]

List available repositories owned by the user.  If "all" is given, list all
repositories (even those not owned by the user).

=item find <regexp>

Find all repositories matching the given regular expression.

=item create <repo>

Create a new repository (not implemented).

=item rename <from> <to>

Rename an existing repository.

=item fork <from> <to>

Fork (copy) an existing repository.  You may fork from any repo, but you may
only fork to your user directory.

=item delete <repo>

Delete an existing repository.  The repository is moved to the "deleted"
directory, with the current timestamp appended, and can be restored using the
"undelete" command.

=item undelete <repo>

Undo a "delete" operation (not implemented).

=item help

Show available commands.

=item git-upload-pack <repo>

Called by "git fetch".

=item git-receive-pack <repo>

Called by "git push".

=back


=head1 CONFIGURATION

The following directions were modified from
http://eagain.net/blog/2007/03/22/howto-host-git.html

=over 4

=item 1

Create a 'git' user.

    sudo adduser \
        --system \
        --home /path/to/git/repos \
        --no-create-home \
        --shell /bin/sh \
        --gecos 'git version control' \
        --group \
        --disabled-password \
        git

=item 2

Add an authorized_keys entry to ~git/.ssh/authorized_keys.  The following
should be all on one line; there should be no whitespace at all where the
linebreaks are.

    command="/path/to/git-ssh-server jdoe",no-p
      ort-forwarding,no-X11-forwarding,no-agent-forwar
      ding,no-pty ssh-rsa ... jdoe@example.com

=back

=head1 BUGS

$SSH_ORIGINAL_COMMAND strips quotes and mashes all the arguments together, so
if any argument has a space in it, it is parsed as a separate argument.
Unless your path has a space in it, this is not a problem.  Otherwise, you
have a problem.

There is no checking of lock files or anything, so if you delete a repository
while someone is fetching, bad stuff may happen.

=head1 TODO

Add a "clone" command?

Add project (that is, non-user) directories?

Call "git update-server-info" after a push?

=head1 AUTHOR

Mark Lodato <lodatom@gmail.com>



