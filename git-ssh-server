#!/usr/bin/perl

use warnings;
use strict;

use Getopt::Long;
use Pod::Usage;
use File::Path;
use File::Basename;
use File::Mirror;
use DateTime;
use Cwd;
use Log::Trivial;


# Configuration
my $git = "/usr/local/bin/git";         # path to git executable
my $base_path = "/var/www/git";         # home directory of 'git' user
my $deleted_path = "/var/www/git-deleted";    # deleted archive
my $log_filename = "/var/www/git/log";  # access log


my $user;
my $logger;

my %available_commands = (
    "help"              => \&help,
    "create"            => \&create,
    "delete"            => \&delete,
    "undelete"          => \&undelete,
    "rename"            => \&rename,
    "fork"              => \&fork,
    "list"              => \&list,
    "git"               => \&git,
    "git-upload-pack"   => \&git_upload_pack,
    "git-receive-pack"  => \&git_receive_pack,
    "upload-pack"       => \&git_upload_pack,
    "receive-pack"      => \&git_receive_pack,
);

exit main();

sub main {
    chdir $base_path;

    GetOptions(
        'help' => sub { pod2usage(-verbose => 2); },
        'man' => sub { pod2usage(-verbose => 99,
            -sections => "NAME|SYNOPSIS|DESCRIPTION|AVAILABLE COMMANDS"); },
    ) or pod2usage(1);
    return pod2usage(1) if @ARGV != 1;

    $user = $ARGV[0];
    my $original_command = $ENV{'SSH_ORIGINAL_COMMAND'};

    if (not defined $original_command) {
        die "\$SSH_ORIGINAL_COMMAND must be set\n";
    }

    if ($original_command =~ /^\s*$/) {
        return &help();
    }

    my @command = split /\s+/, $original_command;

    $logger = Log::Trivial->new(log_file => $log_filename, log_tag => $user);
    $logger->write(join ' ', @command);

    my $cmd = shift @command;
    @ARGV = @command;

    my $routine = $available_commands{$cmd};
    return $routine->() if defined $routine;
    die "unknown command `$cmd'\n";
}

sub help {
    pod2usage(-verbose => 99, -sections => "AVAILABLE COMMANDS");
}

sub create {
    if (@ARGV != 1) {
        die "usage: create <repo>\n";
    }
    my $repo = repo_path_from_name($ARGV[0]);
    my $oldcwd = getcwd;
    mkpath($repo);
    chdir($repo) or die "failed to chdir: $!\n";
    run("git", "init", "--bare");
    chdir $oldcwd;
    return 0;
}

sub delete {
    my ($name) = @ARGV;
    if (@ARGV != 1) {
        die "usage: rename <repo>\n";
    }
    my $from = repo_path_from_name($name);
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    my $now = DateTime->now;
    my $to = "$deleted_path/$from." . $now->ymd('-') . '_' . $now->hms(':');
    mkpath(dirname($to));
    if (not rename($from, $to)) {
        die "rename('$from','$to') failed\n";
    }
    print "sucessfully deleted '$from'\n";
    return 0;
}

sub undelete {
    die "undelete not implemented\n";
}

sub rename {
    my ($from_name, $to_name) = @ARGV;
    if (@ARGV != 2) {
        die "usage: rename <from> <to>\n";
    }
    my $from = repo_path_from_name($from_name);
    my $to   = repo_path_from_name($to_name);
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    if ( -e $to ) {
        die "$to already exists\n";
    }
    if (not rename($from, $to)) {
        die "rename('$from','$to') failed\n";
    }
    print "sucessfully renamed '$from' to '$to'\n";
    return 0;
}

sub fork {
    my ($from_name, $to_name) = @ARGV;
    if (@ARGV < 1 || @ARGV > 2) {
        die "usage: fork <from> [<to>]\n";
    }
    my $from = repo_path_from_name($from_name, 'r');
    if (not $to_name) {
        $from =~ m{/([^/]+)\.git$};
        $to_name = $1;
    }
    my $to = repo_path_from_name($to_name);
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    if ( -e $to ) {
        die "$to already exists\n";
    }
    mirror($from, $to);
    print "sucessfully forked '$from' to '$to'\n";
    return 0;
}

sub list {
    my @repos;
    my ($type, $regexp) = @ARGV;
    my $glob;
    my %types = (
        all => "*/*.git",
        mine => "$user/*.git",
        deleted => "$deleted_path/$user/*.git.*",
    );
    if (@ARGV == 0) {
        $type = "all";
    }
    elsif (@ARGV == 1) {
        if (not exists $types{$type}) {
            $regexp = $type;
            $type = "all";
        }
    }
    $glob = $types{$type};
    if (@ARGV > 2 or not defined $glob) {
        die "usage: list [mine|all|deleted] [<regexp>]\n";
    }
    @repos = glob $glob;
    grep s/^$deleted_path//, @repos;
    if ($regexp) {
        @repos = grep /$regexp/, @repos;
    }
    if (@repos == 0) {
        print "No repositories found.\n";
    }
    else {
        print join("\n", @repos) . "\n";
    }
    return 0;
}

sub git {
    my $cmd = shift(@ARGV);
    if (defined $cmd) {
        if ($cmd eq "upload-pack") {
            return &git_upload_pack();
        }
        if ($cmd eq "receive-pack") {
            return &git_receive_pack();
        }
    }
    die "usage: git (upload|receive)-pack <repo>\n";
}

sub git_upload_pack {
    if (@ARGV != 1) {
        die "usage: git upload-pack <repo>\n";
    }
    my $repo = repo_path_from_name($ARGV[0], 'r');
    return run($git, "upload-pack", "--strict", $repo);
}

sub git_receive_pack {
    if (@ARGV != 1) {
        die "usage: git receive-pack <repo>\n";
    }
    my $repo = repo_path_from_name($ARGV[0]);
    return run($git, "receive-pack", $repo);
    # TODO call git update-server-info?
}


sub repo_path_from_name {
    my ($name, @options) = @_;
    my $read_allowed = 0;
    for (@options) {
        if (/^(r|read|read_allowed)$/) {
            $read_allowed = 1;
        }
        else {
            die "unknown option \"$_\" to repo_path_from_name()\n";
        }
    }
    if ($name =~ /^['"](.*)['"]$/) {
        $name = $1;
    }
    if ($name =~ m{^([a-z0-9_-]+)(\.git)?$}) {
        return "$user/$1.git";
    }
    elsif ($name =~ m{^/?([a-z0-9_-]+)/([a-z0-9_-]+)(\.git)?/?$}) {
        unless ($read_allowed or $1 eq $user) {
            die "you do not have permission to modify '$name'\n";
        }
        return "$1/$2.git";
    }
    else {
        die "invalid repository name '$name'; run `help' for more info\n";
    }
}


sub run {
    system(@_);
    if ($? == -1) {
        die "failed to execute: $!\n";
    }
    elsif ($? & 127) {
        die "child died with signal " . ($? & 127) . "\n";
    }
    return $? >> 8;
}


__END__

=head1 NAME

git-ssh-server - A more useful git-shell.

=head1 SYNOPSIS

git-ssh-server user

git-ssh-server (--help | --man)

=head1 DESCRIPTION

Run commands from $SSH_ORIGINAL_COMMAND as a git restricted shell, allowing
access only to the directories accessible by given user.

This script is usually run automatically by ssh, as in:

    ssh git@server create foo

with a properly set up .ssh/authorized_keys file will run:

    SSH_ORIGINAL_COMMAND='create foo' git-ssh-server jsmith

The user will only be allowed to modify git repositories under the path
allocated to jsmith.


=head1 AVAILABLE COMMANDS

In the following commands, <repo>, <from>, and <to> must be of the form
"[userdir/]reponame[.git]".  If "userdir" is not given, it is taken to be the
current user's directory.  The ".git" suffix is optional.  "reponame" can only
contain lowercase letters, numbers, underscores, and dashes.

=over

=item list [all|mine|deleted] [<regexp>]

List repositories (optionally matching Perl regexp).  If "mine", only match
repositories owned by you; if "deleted", list repositories deleted by you.

=item create <repo>

Create a new, empty repository.

=item rename <from> <to>

Rename an existing repository.

=item fork <from> [<to>]

Fork (copy) an existing repository.  You may fork from any repo, but you may
only fork to your user directory.  If `to' is not given, uses the same
basename as `from'.

=item delete <repo>

Delete an existing repository.  The repository is moved to the "deleted"
directory, with the current timestamp appended, and can be restored using the
"undelete" command.

=item undelete <repo>

Undo a "delete" operation (not implemented).

=item help

Show available commands.

=item git-upload-pack <repo>

Called by "git fetch".

=item git-receive-pack <repo>

Called by "git push".

=back


=head1 CONFIGURATION

The following directions were modified from
http://eagain.net/blog/2007/03/22/howto-host-git.html

=over 4

=item 1

Create a 'git' user.

    sudo adduser \
        --system \
        --home /path/to/git/repos \
        --no-create-home \
        --shell /bin/sh \
        --gecos 'git version control' \
        --group \
        --disabled-password \
        git

=item 2

Add an authorized_keys entry to ~git/.ssh/authorized_keys.  The following
should be all on one line; there should be no whitespace at all where the
linebreaks are.

    command="/path/to/git-ssh-server jdoe",no-p
      ort-forwarding,no-X11-forwarding,no-agent-forwar
      ding,no-pty ssh-rsa ... jdoe@example.com

=back

=head1 BUGS

$SSH_ORIGINAL_COMMAND strips quotes and mashes all the arguments together, so
if any argument has a space in it, it is parsed as a separate argument.
Unless your path has a space in it, this is not a problem.  Otherwise, you
have a problem.

There is no checking of lock files or anything, so if you delete a repository
while someone is fetching, bad stuff may happen.

=head1 TODO

Add a "clone" command?

Add project (that is, non-user) directories?

Call "git update-server-info" after a push?

=head1 AUTHOR

Mark Lodato <lodatom@gmail.com>



