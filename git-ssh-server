#!/usr/bin/perl

use warnings;
use strict;

use Getopt::Long;
use Pod::Usage;
use File::Path;
use File::Basename;
use File::Mirror;
use DateTime;
use Cwd;
use Log::Trivial;


# Configuration
my $git = "/usr/local/bin/git";         # path to git executable
my $base_path = "/var/www/git";         # home directory of 'git' user
my $deleted_path = "/var/www/git-deleted";    # deleted archive
my $log_filename = "/var/www/git/log";  # access log


my $orig_dir = getcwd;
my $user;
my $logger;

my %available_commands = (
    "help"              => \&help,
    "create"            => \&create,
    "delete"            => \&delete,
    "undelete"          => \&undelete,
    "rename"            => \&rename,
    "fork"              => \&fork,
    "list"              => \&list,
    "git"               => \&git,
    "git-upload-pack"   => \&git_upload_pack,
    "git-receive-pack"  => \&git_receive_pack,
    "upload-pack"       => \&git_upload_pack,
    "receive-pack"      => \&git_receive_pack,
);

exit main();

sub main {
    GetOptions(
        'help' => sub { pod2usage(-verbose => 2); },
        'man' => sub { pod2usage(-verbose => 99,
            -sections => "NAME|SYNOPSIS|DESCRIPTION|AVAILABLE COMMANDS"); },
    ) or pod2usage(1);
    return pod2usage(1) if @ARGV != 1;

    $user = $ARGV[0];
    my $original_command = $ENV{'SSH_ORIGINAL_COMMAND'};

    if (not defined $original_command) {
        if (exists $ENV{'SSH_CONNECTION'}) {
            return &help();
        }
        else {
            die "\$SSH_ORIGINAL_COMMAND must be set\n";
        }
    }

    if ($original_command =~ /^\s*$/) {
        return &help();
    }

    my @command = split /\s+/, $original_command;

    $logger = Log::Trivial->new(log_file => $log_filename, log_tag => $user);
    $logger->write(join ' ', @command);

    my $cmd = shift @command;
    @ARGV = @command;

    chdir $base_path;
    my $routine = $available_commands{$cmd};
    return $routine->() if defined $routine;
    die "unknown command `$cmd'; run `help' for more information\n";
}

sub help {
    chdir $orig_dir;
    pod2usage(-verbose => 99, -sections => "AVAILABLE COMMANDS");
}

sub create {
    if (@ARGV != 1) {
        die "usage: create <repo>\n";
    }
    my $repo = repo_path_from_name($ARGV[0]);
    my $oldcwd = getcwd;
    mkpath($repo);
    chdir($repo) or die "failed to chdir: $!\n";
    run("git", "init", "--bare");
    chdir $oldcwd;
    return 0;
}

sub delete {
    my ($name) = @ARGV;
    if (@ARGV != 1) {
        die "usage: rename <repo>\n";
    }
    my $from = repo_path_from_name($name);
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    my $now = DateTime->now;
    my $to = "$deleted_path/$from." . $now->ymd('-') . '_' . $now->hms(':');
    mkpath(dirname($to));
    if (not rename($from, $to)) {
        die "rename('$from','$to') failed\n";
    }
    print "sucessfully deleted '$from'\n";
    return 0;
}

sub undelete {
    my ($from_name, $to_name) = @ARGV;
    if (@ARGV < 1 || @ARGV > 2) {
        die "usage: rename <repo> [<to>]\n";
    }
    my ($from, $to);
    my $from_glob = deleted_repo_glob_from_name($from_name);
    if ($to_name) {
        $to = repo_path_from_name($to_name);
    }
    else {
        $to = repo_path_from_other_path($from_glob);
    }
    my @from_possibilities = glob $from_glob;
    if (@from_possibilities < 1) {
        $from_glob =~ s[^$deleted_path/][];
        die "No deleted repositories found matching $from_glob\n";
    }
    elsif (@from_possibilities > 1) {
        grep {s[^$deleted_path/][]} @from_possibilities;
        die "Multiple deleted repositories found:\n"
            . join("\n",@from_possibilities) . "\n";
    }
    $from = $from_possibilities[0];
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    if ( -e $to ) {
        die "$to already exists\n";
    }
    if (not rename($from, $to)) {
        die "rename('$from','$to') failed\n";
    }
    $from =~ s[^$deleted_path/][];
    print "sucessfully restored '$from' to '$to'\n";
    return 0;
}

sub rename {
    my ($from_name, $to_name) = @ARGV;
    if (@ARGV != 2) {
        die "usage: rename <from> <to>\n";
    }
    my $from = repo_path_from_name($from_name);
    my $to   = repo_path_from_name($to_name);
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    if ( -e $to ) {
        die "$to already exists\n";
    }
    if (not rename($from, $to)) {
        die "rename('$from','$to') failed\n";
    }
    print "sucessfully renamed '$from' to '$to'\n";
    return 0;
}

sub fork {
    my ($from_name, $to_name) = @ARGV;
    if (@ARGV < 1 || @ARGV > 2) {
        die "usage: fork <from> [<to>]\n";
    }
    my $from = repo_path_from_name($from_name, 'r');
    my $to;
    if ($to_name) {
        $to = repo_path_from_name($to_name);
    }
    else {
        $to = repo_path_from_other_path($to_name);
    }
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    if ( -e $to ) {
        die "$to already exists\n";
    }
    mirror($from, $to);
    print "sucessfully forked '$from' to '$to'\n";
    return 0;
}

sub list {
    my @repos;
    my ($type, $regexp) = @ARGV;
    my $glob;
    my %types = (
        all => "*/*.git",
        mine => "$user/*.git",
        deleted => "$deleted_path/$user/*.git.*",
    );
    if (@ARGV == 0) {
        $type = "all";
    }
    elsif (@ARGV == 1) {
        if (not exists $types{$type}) {
            $regexp = $type;
            $type = "all";
        }
    }
    $glob = $types{$type};
    if (@ARGV > 2 or not defined $glob) {
        die "usage: list [mine|all|deleted] [<regexp>]\n";
    }
    @repos = glob $glob;
    grep s{^$deleted_path/}{}, @repos;
    if ($regexp) {
        @repos = grep /$regexp/, @repos;
    }
    if (@repos == 0) {
        print "No repositories found.\n";
    }
    else {
        print join("\n", @repos) . "\n";
    }
    return 0;
}

sub git {
    my $cmd = shift(@ARGV);
    if (defined $cmd) {
        if ($cmd eq "upload-pack") {
            return &git_upload_pack();
        }
        if ($cmd eq "receive-pack") {
            return &git_receive_pack();
        }
    }
    die "usage: git (upload|receive)-pack <repo>\n";
}

sub git_upload_pack {
    if (@ARGV != 1) {
        die "usage: git upload-pack <repo>\n";
    }
    my $repo = repo_path_from_name($ARGV[0], 'r');
    return run($git, "upload-pack", "--strict", $repo);
}

sub git_receive_pack {
    if (@ARGV != 1) {
        die "usage: git receive-pack <repo>\n";
    }
    my $repo = repo_path_from_name($ARGV[0]);
    return run($git, "receive-pack", $repo);
    # TODO call git update-server-info?
}


sub repo_path_from_name {
    my ($name, @options) = @_;
    my $read_allowed = 0;
    for (@options) {
        if (/^(r|read|read_allowed)$/) {
            $read_allowed = 1;
        }
        else {
            die "unknown option \"$_\" to repo_path_from_name()\n";
        }
    }
    $name =~ s/^['"](.*)['"]$/$1/;
    if ($name =~ m{^([a-z0-9_-]+)(\.git)?$}) {
        return "$user/$1.git";
    }
    elsif ($name =~ m{^/?([a-z0-9_-]+)/([a-z0-9_-]+)(\.git)?/?$}) {
        unless ($read_allowed or $1 eq $user) {
            die "you do not have permission to modify '$name'\n";
        }
        return "$1/$2.git";
    }
    else {
        die "invalid repository name '$name'; run `help' for more info\n";
    }
}

sub deleted_repo_glob_from_name {
    my ($name) = @_;
    $name =~ s/^['"](.*)['"]$/$1/;
    if ($name =~ m{^/?(?:$user/)?([a-z0-9_-]+)(?:\.git)?(\.[0-9_:-]+)?/?$}) {
        my $date = $2 || "";
        return "$deleted_path/$user/$1.git$date*";
    }
    else {
        die "invalid repository name '$name'; run `help' for more info\n";
    }
}

sub repo_path_from_other_path {
    my ($other) = @_;
    $other =~ m{/([^/]+)\.git};
    return repo_path_from_name($1);
}


sub run {
    system(@_);
    if ($? == -1) {
        die "failed to execute: $!\n";
    }
    elsif ($? & 127) {
        die "child died with signal " . ($? & 127) . "\n";
    }
    return $? >> 8;
}


__END__

=head1 NAME

git-ssh-server - A more useful git-shell.

=head1 SYNOPSIS

git-ssh-server user

git-ssh-server (--help | --man)

=head1 DESCRIPTION

Run commands from $SSH_ORIGINAL_COMMAND as a git restricted shell, allowing
access only to the directories accessible by given user.

This script is usually run automatically by ssh, as in:

    ssh git@server create foo

with a properly set up .ssh/authorized_keys file will run:

    SSH_ORIGINAL_COMMAND='create foo' git-ssh-server jsmith

The user will only be allowed to modify git repositories under the path
allocated to jsmith.


=head1 AVAILABLE COMMANDS

To use this server, run one of the following commands on the `ssh` command
line.  For example: `ssh git@hostname list mine`.

In the following descriptions, <repo>, <from>, and <to> must be of the form
"[userdir/]reponame[.git]".  If "userdir" is not given, it is taken to be the
current user's directory.  The ".git" suffix is optional.  "reponame" can only
contain lowercase letters, numbers, underscores, and dashes.

=over 25

=item list [all|mine|deleted] [<regexp>]

List repositories (optionally matching Perl regexp).  If "mine", only match
repositories owned by you; if "deleted", list repositories deleted by you.

=item create <repo>

Create a new, empty repository.

=item rename <from> <to>

Rename an existing repository.

=item fork <from> [<to>]

Fork (copy) an existing repository.  You may fork from any repo, but you may
only fork to your user directory.  If `to' is not given, uses the same
basename as `from'.

=item delete <repo>

Delete an existing repository.  The repository is moved to the "deleted"
directory, with the current timestamp appended, and can be restored using the
"undelete" command.

=item undelete <repo>

Undo a "delete" operation.

=item help

Show available commands.

=item git-upload-pack <repo>

Called by "git fetch".

=item git-receive-pack <repo>

Called by "git push".

=back


=head1 CONFIGURATION

The following directions were modified from
http://eagain.net/blog/2007/03/22/howto-host-git.html

=over 4

=item 1

Create a 'git' user.

    sudo adduser \
        --system \
        --home /var/www/git \
        --no-create-home \
        --shell /bin/sh \
        --gecos 'git version control' \
        --group \
        --disabled-password \
        git

=item 2

For each user, add an authorized_keys entry to ~git/.ssh/authorized_keys.  The
following should be all on one line; there should be no whitespace at all
where the linebreaks are.

    command="/path/to/git-ssh-server jdoe",no-p
      ort-forwarding,no-X11-forwarding,no-agent-forwar
      ding ssh-rsa ... jdoe@example.com

=back

=head1 BUGS

$SSH_ORIGINAL_COMMAND strips quotes and mashes all the arguments together, so
if any argument has a space in it, it is parsed as a separate argument.
Unless your path has a space in it, this is not a problem.  Otherwise, you
have a problem.

There is no checking of lock files or anything, so if you delete a repository
while someone is fetching, bad stuff may happen.

=head1 TODO

Add project (that is, non-user) directories?

Call "git update-server-info" after a push?

=head1 AUTHOR

Mark Lodato <lodatom@gmail.com>



