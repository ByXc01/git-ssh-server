#!/usr/bin/perl

use warnings;
use strict;

use Getopt::Long;
use Pod::Usage;
use File::Path;
use File::Basename;

# Configuration
my $git = "/usr/local/bin/git";         # path to git executable
my $base_path = "/var/www/git";         # home directory of 'git' user
my $deleted_path = "/var/www/git-deleted";    # deleted archive


my $user;

my %available_commands = (
    "help"              => \&help,
    "create"            => \&create,
    "delete"            => \&delete,
    "rename"            => \&rename,
    "list"              => \&list,
    "git-upload-pack"   => \&git_upload_pack,
    "git-receive-pack"  => \&git_receive_pack,
);

exit main();

sub main {
    chdir $base_path;

    GetOptions(
        'help' => sub { pod2usage(-verbose => 2); },
        'man' => sub { pod2usage(-verbose => 99,
            -sections => "NAME|SYNOPSIS|DESCRIPTION|AVAILABLE COMMANDS"); },
    ) or pod2usage(1);
    return pod2usage(1) if @ARGV != 1;

    $user = $ARGV[0];
    my $original_command = $ENV{'SSH_ORIGINAL_COMMAND'};

    if (not defined $original_command) {
        die "\$SSH_ORIGINAL_COMMAND must be set\n";
    }

    if ($original_command =~ /^\s*$/) {
        return &help();
    }

    my @command = split /\s+/, $original_command;
    my $cmd = shift @command;
    @ARGV = @command;

    my $routine = $available_commands{$cmd};
    return $routine->() if defined $routine;
    die "unknown command `$cmd'\n";
}

sub help {
    pod2usage(-verbose => 99, -sections => "AVAILABLE COMMANDS");
}

sub create {
    die "create not implemented\n";
}

sub delete {
    my ($name) = @ARGV;
    if (@ARGV != 1) {
        die "usage: rename repo\n";
    }
    my $from = repo_path_from_name($name);
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    if (not yes_no_prompt("Are you SURE you want to delete '$from'?")) {
        print "Delete operation cancelled\n";
        return 0;
    }
    my $to = "$deleted_path/$from." . time();
    mkpath(basename($to));
    if (not rename($from, $to)) {
        die "rename('$from','$to') failed\n";
    }
    print "sucessfully deleted '$from'\n";
    return 0;
}

sub rename {
    my ($from_name, $to_name) = @ARGV;
    if (@ARGV != 2) {
        die "usage: rename from to\n";
    }
    my $from = repo_path_from_name($from_name);
    my $to   = repo_path_from_name($to_name);
    if ( not -e $from ) {
        die "$from does not exist\n";
    }
    if ( -e $to ) {
        die "$to already exists\n";
    }
    if (not rename($from, $to)) {
        die "rename('$from','$to') failed\n";
    }
    print "sucessfully renamed '$from' to '$to'\n";
    return 0;
}

sub list {
    my $type = $ARGV[0] || "mine";
    if (@ARGV > 1 or ($type ne "all" and $type ne "mine")) {
        die "usage: list [all|mine]\n";
    }
    my @repos;
    if ($type eq "all") {
        @repos = glob "*/*.git";
        print "No repositories found.\n" if @repos == 0;
    }
    else {
        @repos = glob "$user/*.git";
        print "You do not own any repositories.\n" if @repos == 0;
    }
    if (@repos > 0) {
        print join("\n", @repos) . "\n";
    }
    return 0;
}

sub git_upload_pack {
    die "git-upload-pack not implemented\n";
}

sub git_receive_pack {
    die "git-receive-pack not implemented\n";
}


sub repo_path_from_name {
    my ($name, $read_allowed) = @_;
    if ($name =~ m{^([a-z0-9_-]+)$}) {
        return "$user/$1.git";
    }
    elsif ($name =~ m{^/?([a-z0-9_-]+)/([a-z0-9_-]+)(\.git)?/?}) {
        unless ($read_allowed or $1 eq $user) {
            die "you do not have permission to modify '$name'\n";
        }
        return "$1/$2.git";
    }
    else {
        die "invalid repository name '$name' - valid characters: a-z0-9_-\n";
    }
}


sub yes_no_prompt {
    my ($prompt) = @_;
    print "$prompt (yes/no) ";
    my $ans = lc <STDIN>;
    until ($ans eq "yes" or $ans =~ /^n/) {
        print "Please type \"yes\" or \"no\". ";
        $ans = lc <STDIN>;
    }
    return $ans eq "yes";
}


__END__

=head1 NAME

git-ssh-server - A more useful git-shell.

=head1 SYNOPSIS

git-ssh-server user

git-ssh-server (--help | --man)

=head1 DESCRIPTION

Run commands from $SSH_ORIGINAL_COMMAND as a git restricted shell, allowing
access only to the directories accessible by given user.

This script is usually run automatically by ssh, as in:

    ssh git@server create foo

with a properly set up .ssh/authorized_keys file will run:

    SSH_ORIGINAL_COMMAND='create foo' git-ssh-server jsmith

The user will only be allowed to modify git repositories under the path
allocated to jsmith.


=head1 AVAILABLE COMMANDS

=over 20

=item list

list available repositories

=item create

create a new repository

=item rename

rename an existing repository

=item delete

delete an existing repository

=item help

show this help message

=item git-upload-pack

called by "git fetch"

=item git-receive-pack

called by "git pull"

=back


=head1 CONFIGURATION

The following directions were modified from
http://eagain.net/blog/2007/03/22/howto-host-git.html

=over 4

=item 1

Create a 'git' user.

    sudo adduser \
        --system \
        --home /path/to/git/repos \
        --no-create-home \
        --shell /bin/sh \
        --gecos 'git version control' \
        --group \
        --disabled-password \
        git

=item 2

Add an authorized_keys entry to ~git/.ssh/authorized_keys.  The following
should be all on one line; there should be no whitespace at all where the
linebreaks are.

    command="/path/to/git-ssh-server jdoe",no-p
      ort-forwarding,no-X11-forwarding,no-agent-forwar
      ding,no-pty ssh-rsa ... jdoe@example.com

=back

=head1 BUGS

$SSH_ORIGINAL_COMMAND strips quotes and mashes all the arguments together, so
if any argument has a space in it, it is parsed as a separate argument.
Unless your path has a space in it, this is not a problem.  Otherwise, you
have a problem.

=head1 AUTHOR

Mark Lodato <lodatom@gmail.com>



